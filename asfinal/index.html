<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>1996 → 2025 scroll crossfade</title>
	<style>
		/* Basic reset */
		html,body{height:100%;margin:0;font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}

		/* Page layout: provide scroll space before/after the sticky stage */
		header, footer{padding:2rem;text-align:center}
		.spacer{height:80vh}

		/* The stage stays visible while the user scrolls through the spacer */
		.stage-wrap{position:relative}
		.stage{position:sticky;top:0;height:100vh;overflow:hidden}

			/* Layered images that cover the viewport */
			.stage .img{
				position:absolute;inset:0;background-size:cover;background-position:center center;background-repeat:no-repeat
			}
			.img.bottom{background-image:url('1996.png');z-index:1}
			/* Top image will be clipped horizontally to create a swipe reveal */
			.img.top{background-image:url('2025.png');z-index:2;will-change:clip-path;clip-path:inset(0 100% 0 0)}

			/* corner labels */
						.label{position:absolute;left:50%;top:2rem;transform:translateX(-50%);color:white;font-weight:700;text-shadow:0 2px 6px rgba(0,0,0,.6);z-index:4;display:inline-block;padding:0.35rem 0.7rem;background:rgba(0,0,0,0.45);border-radius:6px;font-size:45px}
						.img .label{z-index:5}
						.img.bottom .label{z-index:1}
						.img.top .label{z-index:6}

									@media (max-width:700px){
										.label{font-size:36px;padding:0.25rem 0.5rem;top:1.5rem}
									}

		/* Small caption to show instructions */
		.caption{position:absolute;left:1rem;bottom:1rem;color:white;text-shadow:0 2px 8px rgba(0,0,0,.6);z-index:3}

		/* Responsive fallback: on narrow screens stack images vertically instead of sticky overlay */
		@media (max-width:700px){
			.stage{position:relative;height:auto}
			.stage .img{position:relative;height:60vh}
			.img.top{transform:none}
			.caption{position:static;padding:1rem;background:rgba(0,0,0,.35);display:inline-block;margin:1rem}
		}

			/* Reduced motion: avoid animating transforms */
			@media (prefers-reduced-motion: reduce){
				.stage .img{transition:none}
			}
	</style>
</head>
<body>
		<header></header>

	<!-- Spacer before the sticky stage so user can start scrolling -->
	<div class="spacer" aria-hidden="true"></div>

	<main class="stage-wrap">
		<section class="stage" id="photo-stage" aria-label="Image crossfade">
			<div class="img bottom" id="img-bottom" role="img" aria-label="1996 image">
				<div class="label">1996</div>
			</div>
			<div class="img top" id="img-top" role="img" aria-label="2025 image">
				<div class="label">2025</div>
			</div>
      
		</section>

		<!-- The trigger spacer determines the scroll length for the crossfade -->
		<div class="spacer" id="trigger" aria-hidden="true"></div>
	</main>

		<footer></footer>

	<script>
		// Small contract: inputs: page scroll; output: set #img-top opacity in [0,1].
		// We compute progress while #photo-stage is sticky: when user scrolls through #trigger height,
		// progress goes from 0 → 1 and we set topOpacity = 1 - progress.

		(function(){
			const top = document.getElementById('img-top');
			const trigger = document.getElementById('trigger');
			const stage = document.getElementById('photo-stage');

			if(!top || !trigger || !stage) return;

			// Respect reduced motion preference: don't animate or attach scroll updates
			const mq = window.matchMedia('(prefers-reduced-motion: reduce)');
			if(mq && mq.matches){
				// For reduced motion, avoid transitions; we'll still use clip-path but update instantly.
				top.style.clipPath = 'inset(0 100% 0 0)';
			}

					// Precompute trigger positions on resize and include pre/post hold zones.
					// We'll treat the trigger spacer as: [preHold | swipeRange | postHold]
					let triggerStart = 0;
					let swipeStart = 0;
					let swipeEnd = 0;
					let triggerEnd = 0;

					// lengths (in px) for pre and post hold. Tweak these to adjust how long the stage stays fixed.
					const preHold = window.innerHeight * 0.25; // hold for 25% of viewport before swipe
					const postHold = window.innerHeight * 0.25; // hold for 25% of viewport after swipe

					function recompute(){
						const stageRect = stage.getBoundingClientRect();
						const triggerRect = trigger.getBoundingClientRect();

						const scrollY = window.scrollY || window.pageYOffset;
						// top of trigger relative to document
						triggerStart = scrollY + triggerRect.top - window.innerHeight; // when bottom of viewport hits trigger top

						// define swipe region inside the trigger spacer with pre/post holds
						swipeStart = triggerStart + preHold;
						swipeEnd = swipeStart + Math.max(0, triggerRect.height - preHold - postHold);

						// end of trigger after postHold
						triggerEnd = triggerStart + triggerRect.height;
					}

											// We'll implement a constant-time reveal during the swipe region.
											// When the user scrolls into swipeStart, we begin a time-based linear animation from currentReveal -> 1 over swipeDuration.
											let targetReveal = 0;
											let currentReveal = 0;
											let animating = false;
											const swipeDuration = 1200; // milliseconds for a full reveal; tweak to change constant speed
											let swipeAnimStart = 0; // timestamp when the time-based reveal started
											let swipeStartReveal = 0; // reveal value at animation start

											function update(){
												const y = window.scrollY || window.pageYOffset;

												if (y <= swipeStart) {
													// before swipe: reset target and stop any running time-based animation
													targetReveal = 0;
													if (animating){ animating = false; }
												} else if (y >= swipeEnd) {
													// after swipe: set fully revealed
													targetReveal = 1;
													currentReveal = 1;
													// apply immediately
													top.style.clipPath = `inset(0 ${100 - currentReveal * 100}% 0 0)`;
													if (animating){ animating = false; }
												} else {
													// inside swipe region: start or continue time-based linear animation
													// If animation not started, start it using currentReveal as base
													if (!animating) {
														animating = true;
														swipeAnimStart = performance.now();
														swipeStartReveal = currentReveal;
														requestAnimationFrame(runSwipeAnimation);
													}
												}
											}

											function runSwipeAnimation(ts){
												if (!animating) return;
												// compute elapsed from swipeAnimStart
												const elapsed = ts - swipeAnimStart;
												const remaining = swipeDuration * (1 - swipeStartReveal);
												// progress normalized from start reveal -> 1
												const t = Math.min(1, elapsed / Math.max(1, remaining));
												currentReveal = swipeStartReveal + (1 - swipeStartReveal) * t;
												top.style.clipPath = `inset(0 ${100 - currentReveal * 100}% 0 0)`;

												if (t < 1) requestAnimationFrame(runSwipeAnimation);
												else animating = false;
											}

			// Throttle scroll using requestAnimationFrame
			let ticking = false;
			function onScroll(){
				if(!ticking){
					window.requestAnimationFrame(function(){
						update();
						ticking = false;
					});
					ticking = true;
				}
			}

			window.addEventListener('resize', function(){ recompute(); update(); });
			window.addEventListener('load', function(){ recompute(); update(); });
			window.addEventListener('scroll', onScroll, {passive:true});

			// Initial compute and set clip-path: start with top hidden so bottom (1996) shows first
			top.style.clipPath = 'inset(0 100% 0 0)';
			recompute(); update();
		})();
	</script>
</body>
</html>

